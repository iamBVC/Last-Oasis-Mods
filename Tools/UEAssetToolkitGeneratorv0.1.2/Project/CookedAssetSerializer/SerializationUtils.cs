using UAssetAPI.FieldTypes;
using UAssetAPI.Kismet.Bytecode;
using static CookedAssetSerializer.KismetExpressionSerializer;

namespace CookedAssetSerializer;

public struct AssetInfo
{
    public UAsset Asset;
    public Dictionary<int, int> Dict;
    public List<string> DisableGeneration;
    public List<string> GeneratedVariables;
    public List<string> ImportVariables;
}

public static class SerializationUtils
{
    public static List<string> VariableWidgets = new()
    {
        "Button",
        "CheckBox",
        "CircularThrobber",
        "ComboBoxString",
        "DetailsView",
        "DynamicEntryBox",
        "EditableText",
        "EditableTextBox",
        "ExpandableArea",
        "Image",
        "InputKeySelector",
        "InvalidationBox",
        "ListView",
        "MenuAnchor",
        "MultiLineEditableText",
        "MultiLineEditableTextBox",
        "NamedSlot",
        "ProgressBar",
        "RetainerBox",
        "RichTextBlock",
        "RichTextSizable",
        "RichTextStylable",
        "SafeZone",
        "SinglePropertyView",
        "Slider",
        "SpinBox",
        "Synth2DSlider",
        "SynthKnob",
        "Throbber",
        "TileView",
        "TreeView",
        "WebBrowser",
        "WidgetSwitcher"
    };
    
    public static JArray SerializeScript(FunctionExport function, AssetInfo assetInfo)
    {
        var jscript = new JArray();
        var index = 0;
        foreach (var instruction in function.ScriptBytecode)
        {
            jscript.Add(SerializeExpression(instruction, ref index, assetInfo.Asset, assetInfo.ImportVariables, true));
        }

        return jscript;
    }

    public static List<string> CollectGeneratedVariables(ClassExport mainobject, AssetInfo assetInfo)
    {
        //Collect variable names generated by SCS components
        if (FindPropertyData(mainobject, "SimpleConstructionScript", out PropertyData scs))
            if (FindPropertyData(((ObjectPropertyData)scs).Value, "AllNodes", out PropertyData allnodes, assetInfo.Asset))
            {
                var nodes = (ArrayPropertyData)allnodes;
                foreach (ObjectPropertyData node in nodes.Value)
                {
                    if (FindPropertyData(node.Value, "InternalVariableName", out PropertyData property, assetInfo.Asset))
                        assetInfo.GeneratedVariables.Add(property.ToString());
                }
            }


        //Collect variables generated by timelines
        if (FindPropertyData(mainobject, "Timelines", out PropertyData _timelines))
        {
            var timelines = (ArrayPropertyData)_timelines;
            foreach (ObjectPropertyData timeline in timelines.Value)
            {
                var timelineindex = timeline.Value.Index - 1;
                var timelineexport = (NormalExport)assetInfo.Asset.Exports[timelineindex];
                if (FindPropertyData(timelineexport, "VariableName", out PropertyData _name))
                    assetInfo.GeneratedVariables.Add(((NamePropertyData)_name).Value.ToName());
                if (FindPropertyData(timelineexport, "DirectionPropertyName", out PropertyData _dname))
                    assetInfo.GeneratedVariables.Add(((NamePropertyData)_dname).Value.ToName());
                if (FindPropertyData(timelineexport, "FloatTracks", out PropertyData _floattracks))
                {
                    var floattracks = (ArrayPropertyData)_floattracks;
                    foreach (StructPropertyData floattrack in floattracks.Value)
                    {
                        if (FindPropertyData(floattrack.Value, "PropertyName", out PropertyData _pname))
                            assetInfo.GeneratedVariables.Add(((NamePropertyData)_pname).Value.ToName());
                    }
                }

                if (FindPropertyData(timelineexport, "VectorTracks", out _floattracks))
                {
                    var floattracks = (ArrayPropertyData)_floattracks;
                    foreach (StructPropertyData floattrack in floattracks.Value)
                    {
                        if (FindPropertyData(floattrack.Value, "PropertyName", out PropertyData _pname))
                            assetInfo.GeneratedVariables.Add(((NamePropertyData)_pname).Value.ToName());
                    }
                }

                if (FindPropertyData(timelineexport, "LinearColorTracks", out _floattracks))
                {
                    var floattracks = (ArrayPropertyData)_floattracks;
                    foreach (StructPropertyData floattrack in floattracks.Value)
                    {
                        if (FindPropertyData(floattrack.Value, "PropertyName", out PropertyData _pname))
                            assetInfo.GeneratedVariables.Add(((NamePropertyData)_pname).Value.ToName());
                    }
                }
            }
        }

        if (assetInfo.Asset.assetType == EAssetType.WidgetBlueprint)
        {
            //Also append widget tree generated variables
            if (FindPropertyData(mainobject, "WidgetTree", out PropertyData _wtree))
            {
                var wtree = (ObjectPropertyData)_wtree;

                if (wtree.Value.Index > 0 && assetInfo.Asset.Exports[wtree.Value.Index - 1] is NormalExport widgettree)
                    if (FindPropertyData(widgettree, "RootWidget", out PropertyData _root))
                    {
                        var root = (ObjectPropertyData)_root;
                        assetInfo.GeneratedVariables = GetAllWidgets(root, assetInfo);
                    }
            }

            if (FindPropertyData(mainobject, "Bindings", out PropertyData _bindings))
            {
                var bindings = (ArrayPropertyData)_bindings;
                foreach (StructPropertyData binding in bindings.Value)
                {
                    if (FindPropertyData(binding.Value, "ObjectName", out PropertyData _objname))
                        assetInfo.GeneratedVariables.Add(((StrPropertyData)_objname).Value.ToString());
                }
                //Console.WriteLine("bindings "+asset.FilePath);
            }

            //if (FindPropertyData(mainobject, "NamedSlots", out PropertyData _namedslots)) {
            //	ArrayPropertyData namedslots = (ArrayPropertyData)_namedslots;
            //	foreach (NamePropertyData nameslot in namedslots.Value) {
            //		GeneratedVariables.Add(nameslot.Value.ToName());
            //	}
            //	//Console.WriteLine("namedslots " + asset.FilePath);
            //}

            ////Also append animations, they always have backing variables too
            if (FindPropertyData(mainobject, "Animations", out PropertyData _animations))
            {
                var animations = (ArrayPropertyData)_animations;
                foreach (ObjectPropertyData animation in animations.Value)
                {
                    if (animation.Value.Index > 0)
                    {
                        var animname = animation.Value.ToExport(assetInfo.Asset).ObjectName.ToName();
                        if (animname.EndsWith("_INST"))
                            assetInfo.GeneratedVariables.Add(animname.Substring(0, animname.Length - 5));
                    }
                }
            }
        }

        return assetInfo.GeneratedVariables;
    }
    
    public static List<string> GetAllWidgets(ObjectPropertyData reftowidget, AssetInfo assetInfo)
    {
        var isvariable = false;
        if (reftowidget.Value.Index > 0 && assetInfo.Asset.Exports[reftowidget.Value.Index - 1] is NormalExport widget)
        {
            if (FindPropertyData(widget, "bIsVariable", out PropertyData _bisvariable))
            {
                var bisvariable = (BoolPropertyData)_bisvariable;
                isvariable = bisvariable.Value;
            }
            else
            {
                if (widget.ClassIndex.IsImport())
                {
                    var baseclass = widget.ClassIndex.ToImport(assetInfo.Asset);
                    if (baseclass.ClassName.ToName() == "Class" &&
                        VariableWidgets.Contains(baseclass.ObjectName.ToName())) isvariable = true;
                    if (baseclass.ClassName.ToName() == "WidgetBlueprintGeneratedClass") isvariable = true;
                }
            }

            if (isvariable) assetInfo.GeneratedVariables.Add(widget.ObjectName.ToName());

            if (FindPropertyData(widget, "Slots", out PropertyData _slots))
            {
                var slots = (ArrayPropertyData)_slots;
                foreach (ObjectPropertyData slot in slots.Value)
                {
                    if (slot.Value.IsExport() && assetInfo.Asset.Exports[slot.Value.Index - 1] is NormalExport child)
                        if (FindPropertyData(child, "Content", out PropertyData content))
                            assetInfo.GeneratedVariables = GetAllWidgets((ObjectPropertyData)content, assetInfo);
                }
            }
        }

        return assetInfo.GeneratedVariables;
    }


    public static JArray SerializeScript(KismetExpression[] code, AssetInfo assetInfo)
    {
        var jscript = new JArray();
        var index = 0;
        foreach (var instruction in code)
        {
            jscript.Add(SerializeExpression(instruction, ref index, assetInfo.Asset, assetInfo.ImportVariables, true));
        }

        return jscript;
    }

    public static JArray SerializeInterfaces(List<SerializedInterfaceReference> interfaces, AssetInfo assetInfo)
    {
        var jinterfaces = new JArray();
        foreach (var iinterface in interfaces)
        {
            var jinterface = new JObject();
            jinterface.Add("Class", Index(iinterface.Class, assetInfo.Dict));
            jinterface.Add("PointerOffset", iinterface.PointerOffset);
            jinterface.Add("bImplementedByK2", iinterface.bImplementedByK2);
            jinterfaces.Add(jinterface);
        }

        return jinterfaces;
    }

    public static JObject SerializeFunction(FunctionExport function, AssetInfo assetInfo, bool fieldKind = true)
    {
        //currentfunction = function;
        var jfunc = new JObject();
        if (fieldKind) jfunc.Add("FieldKind", "Function");

        jfunc.Add("ObjectClass", assetInfo.Asset.Imports[Math.Abs(function.TemplateIndex.Index) - 1].ClassName.ToName());
        jfunc.Add("ObjectName", function.ObjectName.ToName());
        jfunc.Add("SuperStruct", Index(function.SuperIndex.Index, assetInfo.Dict));
        jfunc.Add("Children", new JArray());
        var ChildProperties = new JArray();

        foreach (var property in function.LoadedProperties)
        {
            ChildProperties.Add(SerializeProperty(property, assetInfo));
        }

        jfunc.Add("ChildProperties", ChildProperties);
        jfunc.Add("Script", SerializeScript(function, assetInfo));
        jfunc.Add("FunctionFlags", ((uint)function.FunctionFlags).ToString());

        return jfunc;
    }

    public static JObject SerializeProperty(FProperty property, AssetInfo assetInfo, bool fieldKind = true)
    {
        var jprop = new JObject();
        if (fieldKind) jprop.Add("FieldKind", "Property");
        jprop.Add("ObjectClass", property.SerializedType.ToName());
        jprop.Add("ObjectName", property.Name.ToName());

        jprop.Add("ArrayDim", (byte)property.ArrayDim);
        jprop.Add("PropertyFlags", ((long)property.PropertyFlags).ToString());
        jprop.Add("RepNotifyFunc", property.RepNotifyFunc.ToName());
        jprop.Add("BlueprintReplicationCondition", (byte)property.BlueprintReplicationCondition);

        switch (property)
        {
            case FEnumProperty fenum:
            {
                jprop.Add("Enum", Index(fenum.Enum.Index, assetInfo.Dict));
                jprop.Add("UnderlyingProp", SerializeProperty(fenum.UnderlyingProp, assetInfo, false));
                break;
            }
            case FArrayProperty farray:
            {
                jprop.Add("Inner", SerializeProperty(farray.Inner, assetInfo, false));
                break;
            }
            case FSetProperty fset:
            {
                jprop.Add("ElementType", SerializeProperty(fset.ElementProp, assetInfo, false));
                break;
            }
            case FMapProperty fmap:
            {
                jprop.Add("KeyProp", SerializeProperty(fmap.KeyProp, assetInfo, false));
                jprop.Add("ValueProp", SerializeProperty(fmap.ValueProp, assetInfo, false));
                break;
            }
            case FInterfaceProperty finterface:
            {
                jprop.Add("InterfaceClass", Index(finterface.InterfaceClass.Index, assetInfo.Dict));
                break;
            }
            case FBoolProperty fbool:
            {
                jprop.Add("BoolSize", fbool.ElementSize);
                jprop.Add("NativeBool", fbool.NativeBool);
                break;
            }
            case FByteProperty fbyte:
            {
                jprop.Add("Enum", Index(fbyte.Enum.Index, assetInfo.Dict));
                break;
            }
            case FStructProperty fstruct:
            {
                jprop.Add("Struct", Index(fstruct.Struct.Index, assetInfo.Dict));
                break;
            }
            case FNumericProperty fnumeric:
            {
                break;
            }
            case FGenericProperty fgeneric:
            {
                break;
            }
            case FSoftClassProperty fsoftclassprop:
            {
                jprop.Add("MetaClass", Index(fsoftclassprop.MetaClass.Index, assetInfo.Dict));
                break;
            }
            case FSoftObjectProperty fsoftobjprop:
            {
                jprop.Add("PropertyClass", Index(fsoftobjprop.PropertyClass.Index, assetInfo.Dict));
                break;
            }
            case FClassProperty fclassprop:
            {
                jprop.Add("MetaClass", Index(fclassprop.MetaClass.Index, assetInfo.Dict));
                break;
            }
            case FObjectProperty fobjprop:
            {
                jprop.Add("PropertyClass", Index(fobjprop.PropertyClass.Index, assetInfo.Dict));
                break;
            }
            //case FMulticastInlineDelegateProperty fmidelegate: {
            //        jprop.Add("SignatureFunction", Index(fmidelegate.SignatureFunction.Index));
            //        break; };
            //case FMulticastDelegateProperty fmdelegate: {
            //        jprop.Add("SignatureFunction", Index(fmdelegate.SignatureFunction.Index));
            //        break; };
            case FDelegateProperty fdelegate:
            {
                if (fdelegate.SignatureFunction.Index > 0)
                    jprop.Add("SignatureFunction",
                        assetInfo.Asset.Exports[fdelegate.SignatureFunction.Index - 1].ObjectName.ToName());
                else if (fdelegate.SignatureFunction.Index < 0)
                    jprop.Add("SignatureFunction",
                        assetInfo.Asset.Imports[-fdelegate.SignatureFunction.Index - 1].ObjectName.ToName());
                else
                    jprop.Add("SignatureFunction", -1);
                break;
            }
        }


        return jprop;
    }

    public static JObject SerializeListOfProperties(List<PropertyData> data, AssetInfo assetInfo, ref List<int> refObjects, bool _struct = false)
    {
        if (!CheckDuplications(ref data))
        {
        }

        FName prev = null;
        var buffer1 = new JObject();
        var buffer2 = new JObject();

        var jproparray = new JArray();
        JProperty[] jpropvalue = null;

        foreach (var prop in data)
        {
            if (!assetInfo.DisableGeneration.Contains(prop.Name.ToName()))
            {
                if (prop.Name == prev && prop.DuplicationIndex != 0)
                {
                    jpropvalue = SerializePropertyData(prop, assetInfo, ref refObjects);
                    if (_struct)
                    {
                        if (jpropvalue.Length == 1)
                            jproparray.Add(jpropvalue[0].Value);
                        else
                            jproparray.Add(new JObject(jpropvalue));
                    }
                    else
                    {
                        foreach (var inprop in jpropvalue)
                        {
                            jproparray.Add(inprop.Value);
                        }
                    }
                }
                else
                {
                    if (jproparray.Count > 1)
                    {
                        buffer2.Add(prev.ToName(), jproparray);
                        buffer1 = (JObject)buffer2.DeepClone();
                    }
                    else
                    {
                        buffer2 = (JObject)buffer1.DeepClone();
                    }

                    jproparray = new JArray();
                    jpropvalue = SerializePropertyData(prop, assetInfo, ref refObjects);

                    if (_struct)
                    {
                        if (jpropvalue.Length == 1)
                            jproparray.Add(jpropvalue[0].Value);
                        else
                            jproparray.Add(new JObject(jpropvalue));
                    }
                    else
                    {
                        foreach (var inprop in jpropvalue)
                        {
                            jproparray.Add(inprop.Value);
                        }
                    }

                    buffer1.Add(jpropvalue);
                }

                prev = prop.Name;
            }
        }

        if (jproparray.Count > 1)
        {
            buffer2.Add(prev.ToName(), jproparray);
            return buffer2;
        }

        return buffer1;
    }

    public static JObject SerializeNormalExport(NormalExport export, AssetInfo assetInfo, ref List<int> refObjects, int index)
    {
        var jexport = new JObject();

        jexport.Add("ObjectIndex", index);
        jexport.Add("Type", "Export");
        jexport.Add("ObjectClass", Index(export.ClassIndex.Index, assetInfo.Dict));
        jexport.Add("Outer", Index(export.OuterIndex.Index, assetInfo.Dict));
        jexport.Add("ObjectName", export.ObjectName.ToName());
        jexport.Add("ObjectFlags", (long)export.ObjectFlags);
        var properties = SerializeListOfProperties(export.Data, assetInfo, ref refObjects);
        properties.Add("$ReferencedObjects", JArray.FromObject(refObjects.Distinct<int>()));
        jexport.Add("Properties", properties);

        refObjects = new List<int>();
        return jexport;
    }
    
    public static JProperty[] SerializePropertyData(PropertyData property, AssetInfo assetInfo, ref List<int> refObjects, bool withname = true)
    {
        var jprop = new JProperty(property.Name.ToName());

        if (assetInfo.DisableGeneration.Contains(property.Name.ToName())) return null;

        var res = new List<JProperty>();
        switch (property)
        {
            case BoolPropertyData:
            case FloatPropertyData:
            case DoublePropertyData:
            case Int8PropertyData:
            case Int16PropertyData:
            case IntPropertyData:
            case Int64PropertyData:
            case UInt16PropertyData:
            case UInt32PropertyData:
            case UInt64PropertyData:
            case GameplayTagContainerPropertyData:
            case TextPropertyData:
            {
                jprop.Value = property.ToJson();
                res.Add(jprop);
                break;
            }
            case BytePropertyData prop:
            {
                if (prop.ByteType == BytePropertyType.Long)
                    jprop.Value = assetInfo.Asset.GetNameReference(prop.Value).Value;
                else
                    jprop.Value = prop.Value;
                res.Add(jprop);
                break;
            }
            case EnumPropertyData prop:
            {
                jprop.Value = prop.Value.ToName();
                res.Add(jprop);
                break;
            }
            case NamePropertyData prop:
            {
                jprop.Value = prop.Value.ToName();
                res.Add(jprop);
                break;
            }
            case InterfacePropertyData prop:
            {
                jprop.Value = Index(prop.Value.Index, assetInfo.Dict);
                refObjects.Add((int)jprop.Value);
                res.Add(jprop);
                break;
            }
            case ObjectPropertyData prop:
            {
                int index = Index(prop.Value.Index, assetInfo.Dict);
                if (index == -1 && prop.Value.Index != 0)
                {
                    if (prop.Value.ToExport(assetInfo.Asset) is FunctionExport func)
                    {
                        jprop.Value = func.ObjectName.ToName();
                        res.Add(jprop);
                    }
                    else
                    {
                        Console.WriteLine("Non valid object index" + prop.Value.Index);
                    }
                }
                else
                {
                    jprop.Value = index;
                    refObjects.Add(index);
                    res.Add(jprop);
                }

                break;
            }
            case SoftObjectPropertyData prop:
            {
                jprop.Value = prop.Value.ToJson();
                res.Add(jprop);
                break;
            }
            case StrPropertyData prop:
            {
                if (prop.Value != null)
                {
                    jprop.Value = prop.Value.Value;
                    res.Add(jprop);
                }

                break;
            }
            case MapPropertyData prop:
            {
                var jvaluearray = new JArray();
                for (var j = 1; j <= prop.Value.Count; j++)
                {
                    var jobj = new JObject();

                    var key = SerializePropertyData(prop.Value.Keys.ElementAt(j - 1), assetInfo, ref refObjects)[0];
                    var jkey = new JProperty("Key", key.Value);
                    jobj.Add(jkey);

                    if (prop.Value.Values.ElementAt((j - 1)).RawValue != null)
                    {
                        key = SerializePropertyData(prop.Value.Values.ElementAt(j - 1), assetInfo, ref refObjects)[0];
                        jkey = new JProperty("Value", key.Value);
                    }
                    else
                    {
                        jkey = new JProperty("Value", "null");
                    }
                    jobj.Add(jkey);
                    jvaluearray.Add(jobj);
                }

                jprop.Value = jvaluearray;
                res.Add(jprop);
                break;
            }
            //case SetPropertyData prop: { break; }
            case ArrayPropertyData prop:
            {
                var jvaluearray = new JArray();
                foreach (var valueelement in prop.Value)
                {
                    var element = SerializePropertyData(valueelement, assetInfo, ref refObjects);
                    foreach (var ele in element)
                    {
                        jvaluearray.Add(ele.Value);
                    }
                }

                jprop.Value = jvaluearray;
                res.Add(jprop);
                break;
            }
            case UnknownPropertyData:
            {
                jprop.Value = "##NOT SERIALIZED##";
                res.Add(jprop);
                break;
            }
            case RawStructPropertyData:
            {
                jprop.Value = "##NOT SERIALIZED##";
                res.Add(jprop);
                break;
            }
            case DateTimePropertyData:
            case TimespanPropertyData:
            case SmartNamePropertyData:
            case IntPointPropertyData:
            case GuidPropertyData:
            case ColorPropertyData:
            case LinearColorPropertyData:
            case RichCurveKeyPropertyData:
            case QuatPropertyData:
            case RotatorPropertyData:
            case Vector2DPropertyData:
            case Vector4PropertyData:
            case VectorPropertyData:
            case BoxPropertyData:
            case Box2DPropertyData:
            case SoftObjectPathPropertyData:
            case FontCharacterPropertyData:
            case FrameNumberPropertyData:
            case PerPlatformBoolPropertyData:
            case PerPlatformFloatPropertyData:
            case PerPlatformIntPropertyData:
            case MovieSceneFrameRangePropertyData:
            case MovieSceneTrackIdentifierPropertyData:
            case MovieSceneSequenceIDPropertyData:
            case MovieSceneEvaluationKeyPropertyData:
            case MovieSceneEvaluationFieldEntityTreePropertyData:
            case MovieSceneEventParametersPropertyData:
            case MovieSceneSubSequenceTreePropertyData:
            case MovieSceneSegmentIdentifierPropertyData:
            case MovieSceneTrackFieldDataPropertyData:
            //case MovieSceneSequenceInstanceDataPtrPropertyData:
            case MovieSceneFloatChannelPropertyData:
            {
                res.AddRange(((JObject)property.ToJson()).Properties());
                break;
            }
            case FontDataPropertyData prop:
            {
                var value = new JObject();
                var fontdata = prop.Value;
                if (fontdata.bIsCooked)
                {
                    value.Add("FontFaceAsset", Index(fontdata.LocalFontFaceAsset.Index, assetInfo.Dict));
                    refObjects.Add(Index(fontdata.LocalFontFaceAsset.Index, assetInfo.Dict));
                    if (fontdata.FontFilename != null)
                        value.Add("FontFilename", fontdata.FontFilename.ToString());
                    else
                        value.Add("FontFilename", "");
                    value.Add("Hinting", "EFontHinting::" + fontdata.Hinting);
                    value.Add("LoadingPolicy", "EFontLoadingPolicy::" + fontdata.LoadingPolicy);
                    value.Add("SubFaceIndex", fontdata.SubFaceIndex);
                }

                jprop.Value = value;
                res.AddRange(value.Properties());
                break;
            }
            case MovieSceneSegmentPropertyData prop:
            {
                var value = new JObject();
                value.Add("Range", prop.Value.Range.ToJson());
                value.Add("ID", prop.Value.ID.IdentifierIndex);
                value.Add("bAllowEmpty", prop.Value.bAllowEmpty);

                var jimpls = new JArray();


                foreach (var item in prop.Value.Impls)
                {
                    var structres = SerializeListOfProperties(item, assetInfo, ref refObjects, true);
                    jimpls.Add(structres);
                }

                var data = new JObject();
                value.Add("Impls", jimpls);
                jprop.Value = value;
                res.Add(jprop);
                break;
            }
            case SectionEvaluationDataTreePropertyData prop:
            {
                var Tree = prop.Value.Tree;

                var value = new JObject();

                var serdata = new JObject();
                serdata.Add("RootNode", Tree.RootNode.ToJson());

                var entries = new JArray();
                var items = new JArray();
                foreach (var entry in Tree.ChildNodes.Entries)
                {
                    entries.Add(entry.ToJson());
                }

                foreach (var item in Tree.ChildNodes.Items)
                {
                    items.Add(item.ToJson());
                }

                var childnodes = new JObject();

                childnodes.Add("Entries", entries);
                childnodes.Add("Items", items);
                serdata.Add("ChildNodes", childnodes);

                entries = new JArray();
                items = new JArray();
                foreach (var entry in Tree.Data.Entries)
                {
                    entries.Add(entry.ToJson());
                }


                foreach (var item in Tree.Data.Items)
                {
                    var structres = SerializeListOfProperties(item, assetInfo, ref refObjects, true);
                    items.Add(structres);
                }

                var data = new JObject();
                data.Add("Entries", entries);
                data.Add("Items", items);
                serdata.Add("Data", data);
                value.Add("Tree", serdata);
                jprop.Value = value;
                res.Add(jprop);
                break;
            }
            case StructPropertyData prop:
            {
                var structres = SerializeListOfProperties(prop.Value, assetInfo, ref refObjects, true);
                jprop.Value = structres;
                res.Add(jprop);
                break;
            }
            case FieldPathPropertyData prop:
            {
                if (prop.Value.Length == 0)
                {
                    jprop.Value = "##NOT SERIALIZED##";
                    res.Add(jprop);
                    break;
                }

                if (prop.Value.Length > 1)
                    Console.WriteLine("FieldPathPropertyData Values array has more than one name");
                jprop.Value = GetFullName(prop.ResolvedOwner.Index, assetInfo.Asset) + ":" + prop.Value[0].ToName();
                res.Add(jprop);
                break;
            }
            default:
            {
                Console.WriteLine(property.PropertyType.ToName());
                jprop.Value = "##NOT SERIALIZED##";
                res.Add(jprop);
                break;
            }
        }

        return res.ToArray();
    }
    
    public static JProperty SerializeData(List<PropertyData> data, AssetInfo assetInfo, 
        ref List<int> refObjects, bool mainobject = true)
    {
        JProperty jdata;
        refObjects = new List<int>();

        if (mainobject)
            jdata = new JProperty("AssetObjectData");
        else
            jdata = new JProperty("Properties");

        var jdatavalue = new JObject();
        foreach (var property in data)
        {
            var temp = SerializePropertyData(property, assetInfo, ref refObjects);
            if (temp != null) jdatavalue.Add(temp);
        }

        if (mainobject)
        {
            var hasSCS = false;
            foreach (var jprop in jdatavalue.Properties())
            {
                if (jprop.Name == "SimpleConstructionScript")
                {
                    hasSCS = true;
                    break;
                }
            }

            if (!hasSCS) jdatavalue.Add("SimpleConstructionScript", -1);
            if (assetInfo.Asset.assetType == EAssetType.WidgetBlueprint)
            {
                if (!FindPropertyData(data, "Animations", out PropertyData _animations))
                {
                    jdatavalue.Add("Animations", new JArray());
                }
            }
        }

        jdatavalue.Add("$ReferencedObjects", JArray.FromObject(refObjects.Distinct<int>()));
        refObjects = new List<int>();
        jdata.Value = jdatavalue;

        return jdata;
    }

    public static JProperty ObjectHierarchy(AssetInfo assetInfo, ref List<int> refObjects, bool fixnames = false)
    {
        refObjects = new List<int>();
        var ObjHie = new JArray();
        for (var i = 1; i <= assetInfo.Asset.Imports.Count; i++)
        {
            if (assetInfo.Dict.ContainsKey(-i))
            {
                var import = assetInfo.Asset.Imports[i - 1];
                var jimport = new JObject();
                jimport.Add("ObjectIndex", Index(-i, assetInfo.Dict));
                jimport.Add("Type", "Import");
                jimport.Add("ClassPackage", import.ClassPackage.ToName());
                jimport.Add("ClassName", import.ClassName.ToName());
                if (import.OuterIndex.Index != 0) jimport.Add("Outer", Index(import.OuterIndex.Index, assetInfo.Dict));
                if (fixnames && import.OuterIndex.Index < 0 &&
                    import.OuterIndex.ToImport(assetInfo.Asset).ClassName.ToName() == "Package")
                {
                    var package = import.OuterIndex.ToImport(assetInfo.Asset).ObjectName.ToName();
                    var packagename = import.OuterIndex.ToImport(assetInfo.Asset).ObjectName.ToName().Split("/").Last();
                    var assetname = import.ObjectName.ToName();
                    if (package.StartsWith("/Game") && packagename != assetname)
                        jimport.Add("ObjectName", packagename);
                    else
                        jimport.Add("ObjectName", assetname);
                }
                else
                {
                    jimport.Add("ObjectName", import.ObjectName.ToName());
                }

                ObjHie.Add(jimport);
            }
        }

        for (var i = 1; i <= assetInfo.Asset.Exports.Count; i++)
        {
            if (assetInfo.Dict.ContainsKey(i))
            {
                var jexport = new JObject();
                if (i == assetInfo.Asset.mainExport)
                {
                    jexport.Add("ObjectIndex", Index(i, assetInfo.Dict));
                    jexport.Add("Type", "Export");
                    jexport.Add("ObjectMark", "$AssetObject$");
                }
                else
                {
                    switch (assetInfo.Asset.Exports[i - 1])
                    {
                        case FunctionExport:
                        {
                            continue;
                        }
                        case SoundNodeExport:
                        {
                            continue;
                        }
                        case NormalExport normal:
                        {
                            jexport = SerializeNormalExport(normal, assetInfo, 
                                ref refObjects, Index(i, assetInfo.Dict));
                            break;
                        }
                    }
                }

                ObjHie.Add(jexport);
            }
        }

        return new JProperty("ObjectHierarchy", ObjHie);
    }
    
    public static bool FindExternalProperty(UAsset asset, FName propname, out FProperty property)
    {
        var export = asset.GetClassExport();
        if (export != null)
        {
            foreach (var prop in export.LoadedProperties)
            {
                if (prop.Name == propname)
                {
                    property = prop;
                    return true;
                }
            }

            property = new FObjectProperty();
            Console.WriteLine("No " + propname.ToName() + "in ClassExport");
            return false;
        }

        property = new FObjectProperty();
        Console.WriteLine("No ClassExport");
        return false;
    }

    public static bool FindPropertyData(FPackageIndex export, string propname, out PropertyData prop, UAsset asset)
    {
        prop = null;
        if (export.IsExport() && export.ToExport(asset) is NormalExport exp)
        {
            foreach (var property in exp.Data)
            {
                if (property.Name.ToName() == propname)
                {
                    prop = property;
                    return true;
                }
            }
        }

        return false;
    }

    public static bool FindPropertyData(Export export, string propname, out PropertyData prop)
    {
        prop = null;
        if (export is NormalExport exp)
        {
            foreach (var property in exp.Data) {
                if (property.Name.ToName() == propname) {
                    prop = property;
                    return true;
                }
            }
        }
        return false;
    }

    public static bool FindPropertyData(List<PropertyData> list, string propname, out PropertyData prop)
    {
        prop = null;
        foreach (var property in list)
        {
            if (property.Name.ToName() == propname)
            {
                prop = property;
                return true;
            }
        }

        return false;
    }

    public static bool FindPropertyData(List<PropertyData> list, string propname, out PropertyData[] props)
    {
        props = null;
        List<PropertyData> temp = new();
        foreach (var property in list)
        {
            if (property.Name.ToName() == propname)
                temp.Add(property);
        }

        if (temp.Count > 0)
        {
            props = temp.ToArray();
            return true;
        }

        return false;
    }

    public static Dictionary<int, int> FixIndexes(Dictionary<int, int> dict, UAsset asset)
    {
        var index = 0;
        dict.Add(0, -1);

        for (var i = 1; i <= asset.Imports.Count; i++)
        {
            dict.Add(-i, index);
            index++;
        }

        for (var i = 1; i <= asset.Exports.Count; i++)
        {
            if (asset.Exports[i - 1] is not FunctionExport)
            {
                dict.Add(i, index);
                index++;
            }
        }

        return dict;
    }

    public static int GetClassIndex(UAsset asset)
    {
        for (var i = 1; i <= asset.Exports.Count; i++)
        {
            if (asset.Exports[i - 1] is ClassExport)
                return i;
        }

        return 0;
    }

    public static int Index(int index, Dictionary<int, int> dict)
    {
        if (dict.TryGetValue(index, out var validindex))
            return validindex;
        return -1;
    }
    
    public static string GetName(int index, UAsset asset)
    {
        if (index > 0)
            return asset.Exports[index - 1].ObjectName.ToName();
        if (index < 0)
            return asset.Imports[-index - 1].ObjectName.ToName();
        return "";
    }

    public static string GetFullName(int index, UAsset asset)
    {
        if (index > 0)
        {
            if (asset.Exports[index - 1].OuterIndex.Index != 0)
            {
                var parent = GetFullName(asset.Exports[index - 1].OuterIndex.Index, asset);
                return parent + "." + asset.Exports[index - 1].ObjectName.ToName();
            }

            return asset.Exports[index - 1].ObjectName.ToName();
        }

        if (index < 0)
        {
            if (asset.Imports[-index - 1].OuterIndex.Index != 0)
            {
                var parent = GetFullName(asset.Imports[-index - 1].OuterIndex.Index, asset);
                return parent + "." + asset.Imports[-index - 1].ObjectName.ToName();
            }

            return asset.Imports[-index - 1].ObjectName.ToName();
        }
        return "";
    }

    public static string GetParentName(int index, UAsset asset)
    {
        if (index > 0)
        {
            if (asset.Exports[index - 1].OuterIndex.Index != 0)
            {
                var parent = GetFullName(asset.Exports[index - 1].OuterIndex.Index, asset);
                return parent;
            }

            return "";
        }

        if (index < 0)
        {
            if (asset.Imports[-index - 1].OuterIndex.Index != 0)
            {
                var parent = GetFullName(asset.Imports[-index - 1].OuterIndex.Index, asset);
                return parent;
            }

            return "";
        }

        return "";
    }

    public static bool FindProperty(int index, FName propname, out FProperty property, UAsset asset, ref List<string> importVariables)
    {
        if (index < 0)
        {
            var klass = asset.Imports[-index - 1].ClassName.ToName();
            var owner = GetName(index, asset);
            var parent = GetParentName(index, asset);
            var propString = propname.ToName();
            /*if (parent.StartsWith("/Game")) {
                string path = ContentDir + parent.Substring(5).Replace("/","\\")+".uasset";
                if (File.Exists(path)) {
                    UAsset assetcheck = new UAsset(path, UE4Version.VER_UE4_26);
                    //altasset = assetcheck;
                    if (FindExternalProperty(assetcheck, propname, out FProperty prop)) {
                        property = prop;
                        return true;
                    } else {
                        property = new FObjectProperty();
                        return false;
                    }

                } else {
                    Console.WriteLine("No such file on disk "+"Class "+klass+ " Path " +path);
                }
            }*/

            importVariables.Add(klass + " " + owner + " " + propname.ToName());

            property = new FObjectProperty();
            return false;
        }

        var export = asset.Exports[index - 1];
        if (export is StructExport)
            foreach (var prop in (export as StructExport).LoadedProperties)
            {
                if (prop.Name == propname)
                {
                    property = prop;
                    return true;
                }
            }

        property = new FObjectProperty();
        return false;
    }

    public static bool CheckDuplications(ref List<PropertyData> Data)
    {
        for (var i = 0; i < Data.Count; i++)
        {
            if (i != 0)
            {
                if (Data[i].DuplicationIndex > 0)
                {
                    if (Data[i].DuplicationIndex != Data[i - 1].DuplicationIndex + 1 &&
                        Data[i].Name.ToName() == Data[i - 1].Name.ToName())
                    {
                        /*Console.WriteLine("Missing property with lower duplication index  Name : " +
                                          Data[i].Name.ToName() + " Type : " + Data[i].PropertyType.ToName() +
                                          " StructType : " + (Data[i] as StructPropertyData).StructType.ToName());*/

                        return false;
                    }
                }
            }
            else
            {
                if (Data[i].DuplicationIndex > 0)
                {
                    /*Console.WriteLine(" i=0  Missing property with lower duplication index  Name : " +
                                      Data[i].Name.ToName() + " Type : " + Data[i].PropertyType.ToName() +
                                      " StructType : " + (Data[i] as StructPropertyData).StructType.ToName());*/
                    return false;
                }
            }
        }

        return true;
    }
    
    public static JObject GuidToJson(Guid Value)
    {
        var res = new JObject();
        var guid = Value.ToUnsignedInts();
        res.Add(new JProperty("A", (int)guid[0]));
        res.Add(new JProperty("B", (int)guid[1]));
        res.Add(new JProperty("C", (int)guid[2]));
        res.Add(new JProperty("D", (int)guid[3]));
        return res;
    }
}